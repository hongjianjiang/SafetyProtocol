This program should be regarded as a DEBUGGING aid, not as a 
certifier of correctness.
Call with the -l flag or read the license file for terms
and conditions of use.
Run this program with "-h" for the list of options.

Bugs, questions, and comments should be directed to
"melatti@di.uniroma1.it".

CMurphi compiler last modified date: Oct 20 2020
Include files last modified date:    Nov 8 2016
==========================================================================

==========================================================================
Caching Murphi Release 5.4.9.1
Finite-state Concurrent System Verifier.

Caching Murphi Release 5.4.9.1 is based on various versions of Murphi.
Caching Murphi Release 5.4.9.1 :
Copyright (C) 2009-2012 by Sapienza University of Rome.
Murphi release 3.1 :
Copyright (C) 1992 - 1999 by the Board of Trustees of
Leland Stanford Junior University.

==========================================================================

Protocol: result

Algorithm:
	Verification by breadth first search.
	with symmetry algorithm 3 -- Heuristic Small Memory Normalization
	with permutation trial limit 10.

Memory usage:

	* The size of each state is 43800 bits (rounded up to 5480 bytes).
	* The memory allocated for the hash table and state queue is
	  8 Mbytes.
	  With states hash-compressed to 40 bits, the maximum size of
	  the state space is 1379321 states.
	   * Use option "-k" or "-m" to increase this, if necessary.
	* Capacity in queue for breadth-first search: 137932 states.
	   * Change the constant gPercentActiveStates in mu_prolog.inc
	     to increase this, if necessary.

Warning: No trace will not be printed in the case of protocol errors!
         Check the options if you want to have error traces.
aenc{concat(Na,Alice)}PK(Intruder)
roleA[i] in st1
intruder get msg from ch[1].
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
rule adecrypt5
intruder emit msg into ch[1].
intruder get msg from ch[1].
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
rule aencrypt5
rule deconcat3
intruder emit msg into ch[1].
rule adecrypt5
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
rule adecrypt5
intruder emit msg into ch[1].
rule deconcat3
intruder emit msg into ch[1].
intruder emit msg into ch[1].
rule enconcat6
rule aencrypt5
intruder emit msg into ch[1].
rule aencrypt5
rule deconcat3
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
rule aencrypt5
rule deconcat3
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
rule adecrypt5
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
rule aencrypt5
rule deconcat3
intruder emit msg into ch[1].
rule enconcat6
intruder emit msg into ch[1].
intruder emit msg into ch[1].
rule deconcat3
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
rule deconcat3
aenc{concat(Na,Alice)}PK(Bob)
roleB[i] in st1
rule aencrypt7
rule aencrypt5
intruder emit msg into ch[1].
rule enconcat6
rule aencrypt5
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
rule aencrypt5
rule deconcat3
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
rule aencrypt5
rule deconcat3
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
rule deconcat3
intruder emit msg into ch[1].
intruder emit msg into ch[1].
rule enconcat6
rule aencrypt5
intruder emit msg into ch[1].
rule aencrypt7
intruder emit msg into ch[1].
intruder emit msg into ch[1].
rule enconcat6
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
rule enconcat6
aenc{concat(Na,Alice)}PK(Bob)
roleB[i] in st1
rule deconcat3
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
rule deconcat3
aenc{concat(Na,Nb)}PK(Alice)
roleB[i] in st2
rule aencrypt5
intruder emit msg into ch[1].
intruder emit msg into ch[2].
rule aencrypt7
intruder emit msg into ch[1].
intruder emit msg into ch[1].
rule aencrypt7
rule aencrypt5
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
rule enconcat6
rule aencrypt5
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
rule enconcat6
intruder emit msg into ch[1].
intruder emit msg into ch[1].
rule deconcat3
aenc{concat(Na,Alice)}PK(Bob)
roleB[i] in st1
rule aencrypt7
rule aencrypt5
intruder emit msg into ch[1].
intruder emit msg into ch[1].
intruder emit msg into ch[1].
intruder emit msg into ch[2].
rule aencrypt7
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
rule aencrypt7
aenc{concat(Na,Alice)}PK(Bob)
roleB[i] in st1
rule enconcat6
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
rule enconcat6
aenc{concat(Na,Nb)}PK(Alice)
roleB[i] in st2
rule deconcat3
intruder get msg from ch[2].
aenc{concat(Na,Nb)}PK(Alice)
roleA[i] in st2
intruder emit msg into ch[1].
intruder emit msg into ch[1].
intruder emit msg into ch[2].
rule aencrypt5
intruder emit msg into ch[2].
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
rule aencrypt5
intruder emit msg into ch[1].
aenc{concat(Na,Na)}PK(Alice)
roleA[i] in st2
intruder emit msg into ch[1].
intruder emit msg into ch[1].
intruder emit msg into ch[2].
rule aencrypt7
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
rule aencrypt7
aenc{concat(Na,Alice)}PK(Bob)
roleB[i] in st1
rule aencrypt7
rule aencrypt5
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
rule aencrypt7
intruder emit msg into ch[1].
intruder emit msg into ch[1].
rule enconcat6
aenc{concat(Na,Alice)}PK(Bob)
roleB[i] in st1
rule aencrypt5
intruder emit msg into ch[1].
intruder emit msg into ch[2].
rule aencrypt7
intruder emit msg into ch[1].
intruder emit msg into ch[1].
intruder emit msg into ch[2].
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
intruder emit msg into ch[2].
aenc{concat(Na,Alice)}PK(Bob)
roleB[i] in st1
intruder emit msg into ch[1].
intruder emit msg into ch[1].
aenc{concat(Na,Na)}PK(Alice)
roleA[i] in st2
rule aencrypt7
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
rule aencrypt7
aenc{concat(Na,Nb)}PK(Alice)
roleB[i] in st2
rule enconcat6
intruder get msg from ch[2].
aenc{concat(Na,Nb)}PK(Alice)
roleA[i] in st2
rule deconcat3
intruder emit msg into ch[2].
rule deconcat3
aenc{Nb}PK(Intruder)
roleA[i] in st3
intruder emit msg into ch[2].
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
intruder emit msg into ch[2].
aenc{concat(Na,Alice)}PK(Bob)
roleB[i] in st1
intruder emit msg into ch[1].
intruder emit msg into ch[1].
aenc{concat(Na,Na)}PK(Alice)
roleA[i] in st2
rule aencrypt5
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
aenc{concat(Na,Na)}PK(Alice)
roleA[i] in st2
rule aencrypt5
intruder emit msg into ch[2].
aenc{concat(Na,Alice)}PK(Intruder)
roleB[i] in st1
rule aencrypt5
intruder emit msg into ch[1].
aenc{Na}PK(Intruder)
roleA[i] in st3

==========================================================================

Result:

	Invariant "weakB" failed.

State Space Explored:

	95 states, 165 rules fired in 0.10s.

Analysis of State Space:

	There are rules that are never fired.
	If you are running with symmetry, this may be why.  Otherwise,
	please run this program with "-pr" for the rules information.
